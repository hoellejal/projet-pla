Square_1(Move_0){

  * (Move_0) : True ? Move :(Move_1)
  * (Move_1) : True ? Move(R) :(Move_2)
  * (Move_2) : True ? Move(B) :(Move_3)
  * (Move_3) : True ? Move(L) :(Move_0)

}

Square_2(Init){
  
  * (Init) : True ? Move :(Move_1)
  * (Move_1) : True ? Turn(R) : (Init)
  
}

IntelligentForward(Init){

  * (Init) :
  | not(Cell(F,V)) ? Turn(R) : (Init)
  | Cell(F,V) ? Move : (Init)

}

Pop(Init){

  * (Init) : True ? Pop :(Init)

}

Wizz(Init){

  * (Init) : True ? Wizz :(Init)

}

WhaleD(Init){

  * (Init) :
  | Cell(F,D) / Cell(B,D) / Cell(L,D) / Cell(R,D) ? Pop :(Danger)
  | Cell(F,T) / Cell(B,T) / Cell(L,T) / Cell(R,T) ? Pop :(Team)
  | True ? :(Bouge)

  * (Danger) :
  | Cell(F,D) / Cell(B,D) / Cell(L,D) / Cell(R,D) :(Danger)
  | True ? :(Init)

  * (Team) :
  | Cell(F,T) / Cell(B,T) / Cell(L,T) / Cell(R,T) :(Team)
  | True ? :(Init)

  *(Bouge)
  | not(Cell(F,V)) ? Turn(B) :(Bouge_1)
  | True ? :(Bouge)

  *(Bouge_1) True ? Move(F) :(Init)

}

WhaleND(Init){

  *(Init) :
  | Cell(F,D) / Cell(B,D) / Cell(L,D) / Cell(R,D) ? Pop :(Danger)
  | Cell(F,T) / Cell(B,T) / Cell(L,T) / Cell(R,T) ? Pop :(Team)
  | True ? :(Bouge)

  * (Danger) :
  | Cell(F,D) / Cell(B,D) / Cell(L,D) / Cell(R,D) :(Danger)
  | True ? :(Init)

  * (Team) :
  | Cell(F,T) / Cell(B,T) / Cell(L,T) / Cell(R,T) :(Team)
  | True ? :(Init)

  *(Bouge) :
  | not(Cell(F,V)) & Cell(L,V) & Cell(R,V) ? Turn(L) / Turn(R) :(Move_F) 
  | not(Cell(F,V)) & not(Cell(L,V)) & Cell(R,V) & Cell(B,V) ? Turn(R) / Turn(B) :(Move_F)  
  | not(Cell(F,V)) & Cell(L,V) & not(Cell(R,V)) & Cell(B,V) ? Turn(L) / Turn(B) :(Move_F)
  | not(Cell(F,V)) & not(Cell(L,V)) & not(Cell(R,V)) & not(Cell(B,V)) ? Turn(B) :(Move_F)
  | True ? (Rand)

  *(Move_F) : True ? Move :(Init)

  *(Rand) :
  | Cell(F,V) ? Move(F) / Turn(L) :(Rand_2)
  | True ? (Init) 

  *(Rand_2) :
  | Cell(F,V) ? Turn(R) / Turn(L) :(Rand_3)
  | True ? (Init)

  *(Rand_3) : True ? Wizz / Move(F) :(Init)

}

Player(Init){

  * (Init) :
  | Key(z) ? Move(N) :(Turn_N)
  | Key(q) ? Move(W) :(Turn_W)
  | Key(s) ? Move(S) :(Turn_S)
  | Key(d) ? Move(E) :(Turn_E)
  | Key(p) ? Pop :(Init)
  | Key(w) ? Wizz :(Init)
  | Key(SPACE) ? Hit :(Init)
  | Key(e) ? Pick :(Init)
  | True ? Power :(Init)

  * (Turn_N): True ? Turn(N) :(Init)
  * (Turn_W): True ? Turn(W) :(Init)
  * (Turn_S): True ? Turn(S) :(Init)
  * (Turn_E): True ? Turn(E) :(Init)

}

Projectile(Init){

  * (Init) : True ? Move :(Init)

}
